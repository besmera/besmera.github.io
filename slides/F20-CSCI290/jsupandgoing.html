<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dr. Andrew Besmer" />
  <title>JavaScript</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>
    <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="../../reveal.js/css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="../../assets/custom.css"/>
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>

    <link rel="stylesheet" href="../../reveal.js/lib/css/zenburn.css">

    <!--[if lt IE 9]>
    <script src="../../reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">JavaScript</h1>
    <h2 class="author">Dr. Andrew Besmer</h2>
    <h3 class="date">Up &amp; Going</h3>
</section>
<section id="TOC">
<ul>
<li><a href="#/the-basics">The Basics</a></li>
<li><a href="#/types">Types</a></li>
<li><a href="#/type-coercion">Type Coercion</a></li>
<li><a href="#/scoping">Scoping</a></li>
<li><a href="#/objects-more">Objects &amp; More</a></li>
<li><a href="#/functions-1">Functions</a></li>
</ul>
</section>

<section><section id="the-basics" class="title-slide slide level1"><h1>The Basics</h1></section><section id="statementsexpressions" class="slide level2">
<h2>Statements/Expressions</h2>
<ul>
<li>Statements - <code>a = b * 2;</code></li>
<li>Expressions
<ul>
<li>Any reference to a variable or value</li>
<li>or a set of variable(s) and value(s) combined with operators</li>
</ul></li>
<li>Litterals
<ul>
<li>Explicitly written and set without being stored in a variable</li>
</ul></li>
</ul>
</section><section id="comments" class="slide level2">
<h2>Comments</h2>
<ul>
<li>Two forms
<ul>
<li><code>//</code></li>
<li><code>/* */</code></li>
</ul></li>
</ul>
</section><section id="operators" class="slide level2">
<h2>Operators</h2>
<ul>
<li>Logical
<ul>
<li><code>&amp;&amp;</code> <code>||</code> <code>!</code></li>
</ul></li>
<li>Relational
<ul>
<li><code>==</code> <code>===</code> <code>!=</code> <code>!==</code> <code>!</code></li>
<li><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></li>
</ul></li>
</ul>
</section><section id="blocks" class="slide level2">
<h2>Blocks</h2>
<ul>
<li>Code blocks can be formed with <code>{</code> and <code>}</code></li>
</ul>
</section><section id="conditionals" class="slide level2">
<h2>Conditionals</h2>
<ul>
<li><code>if</code></li>
<li><code>if else</code></li>
<li><code>if else if</code></li>
</ul>
<pre><code>if (a == 2) {
    // do something
}
else if (a == 10) {
    // do another thing
}
else if (a == 42) {
    // do yet another thing
}
else {
    // fallback to here
}</code></pre>
</section><section id="switching" class="slide level2">
<h2>Switching</h2>
<pre><code>switch (a) {
    case 2:
        // do something
        break;
    case 10:
        // do another thing
        break;
    case 42:
        // do yet another thing
        break;
    default:
        // fallback to here
}</code></pre>
</section><section id="ternary" class="slide level2">
<h2>Ternary</h2>
<pre><code>var a = 42;

var b = (a &gt; 41) ? &quot;hello&quot; : &quot;world&quot;;

// similar to:

// if (a &gt; 41) {
//    b = &quot;hello&quot;;
// }
// else {
//    b = &quot;world&quot;;
// }</code></pre>
</section><section id="looping" class="slide level2">
<h2>Looping</h2>
<ul>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>do while</code></li>
<li><code>break;</code> and <code>continue;</code></li>
</ul>
<pre><code>var i=0;

for (i = 0; i &lt; 5; i++) {
    console.log(i);
}

while (i &lt; 10) {
    console.log( &quot;The number is &quot; + i++);
}

do {
    console.log( &quot;The number is &quot; + i++);
}
while (i &lt; 10);</code></pre>
</section><section id="variables" class="slide level2">
<h2>Variables</h2>
<ul>
<li>Names of variables and functions must start with <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>$</code>, or <code>_</code> then can contain any <code>0</code>-<code>9</code></li>
<li>They also can not contain reserved words for example, <code>null</code>, <code>true</code>, <code>false</code></li>
<li>Use <code>var</code> or <code>let</code>
<ul>
<li>More later</li>
</ul></li>
</ul>
<pre><code>var x=5;
let x=5;</code></pre>
</section></section>
<section><section id="types" class="title-slide slide level1"><h1>Types</h1></section><section id="types-1" class="slide level2">
<h2>Types</h2>
<ul>
<li>Primatives
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code> and <code>undefined</code></li>
<li><code>object</code></li>
<li><code>symbol</code> (new)</li>
</ul></li>
</ul>
</section><section id="types-2" class="slide level2">
<h2>Types</h2>
<ul>
<li><code>typeof</code> - returns string of one of the above which represents what type the value in the variable is, not what type the variable is</li>
</ul>
<pre><code>var a;
typeof a;               // &quot;undefined&quot;

a = &quot;hello world&quot;;
typeof a;               // &quot;string&quot;

a = 42;
typeof a;               // &quot;number&quot;

a = true;
typeof a;               // &quot;boolean&quot;

a = null;
typeof a;               // &quot;object&quot; -- weird, bug

a = undefined;
typeof a;               // &quot;undefined&quot;

a = { b: &quot;c&quot; };
typeof a;               // &quot;object&quot;</code></pre>
</section><section id="types-3" class="slide level2">
<h2>Types</h2>
<ul>
<li>Other types like <code>array</code>s or <code>function</code>s are specialized versions of the <code>object</code> type</li>
<li>An <code>array</code> is meant to be accessed numerically (<code>0</code> based) and can be easily declared</li>
<li>Automatically have properties like length</li>
</ul>
<pre><code>var arr = [
    &quot;hello world&quot;,
    42,
    true
];

arr[0];         // &quot;hello world&quot;
arr[1];         // 42
arr[2];         // true
arr.length;     // 3

typeof arr;     // &quot;object&quot;</code></pre>
</section><section id="constants" class="slide level2">
<h2>Constants</h2>
<ul>
<li><code>var</code> vs <code>const</code></li>
<li>Convention is to use all caps</li>
</ul>
</section><section id="functions" class="slide level2">
<h2>Functions</h2>
<ul>
<li>Making</li>
<li>Calling</li>
<li>Returns</li>
<li><code>typeof</code> returns <code>function</code> but it is possible to set properties etc.. because it is an <code>object</code></li>
</ul>
<pre><code>function printAmount(amt) {
    return amt.toFixed(2);
}

console.log(printAmount(99.9999));</code></pre>
<ul>
<li>Creating functions inside of functions is possible!</li>
</ul>
</section></section>
<section><section id="type-coercion" class="title-slide slide level1"><h1>Type Coercion</h1></section><section id="typing" class="slide level2">
<h2>Typing</h2>
<ul>
<li>Static typing/type enforcement</li>
<li>Weak typing/dynamic typing/loosly typed</li>
<li>A variables type can change</li>
</ul>
<pre><code>var amount = 99.99;

amount = amount * 2;

console.log( amount );      // 199.98

// convert `amount` to a string, and
// add &quot;$&quot; on the beginning
amount = &quot;$&quot; + String( amount );

console.log( amount );      // &quot;$199.98&quot;</code></pre>
</section><section id="type-coercion-1" class="slide level2">
<h2>Type Coercion</h2>
<ul>
<li>Explicit coercion</li>
</ul>
<pre class="js"><code>var a = &quot;42&quot;;
var b = Number( a );

console.log( a );   // &quot;42&quot;
console.log( b );   // 42</code></pre>
<ul>
<li>Implicit coercion</li>
</ul>
<pre><code>var a = &quot;42&quot;;

var b = a * 1;  // &quot;42&quot; implicitly coerced to 42 here

a;              // &quot;42&quot;
b;              // 42 -- the number!</code></pre>
</section><section id="corecion" class="slide level2">
<h2>Corecion</h2>
<ul>
<li>Type coercion frequently occurs</li>
</ul>
<pre><code>var a = &quot;42&quot;;
var b = 42;

a == b;         // true
a === b;        // false</code></pre>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3">Double Equality Coercion Rules</a></li>
<li><code>if</code> expects <code>boolean</code>, pass <code>number</code> -&gt; <code>boolean</code></li>
</ul>
</section><section id="boolean-falsy" class="slide level2">
<h2>boolean falsy</h2>
<ul>
<li>The following are falsy, all others truthy</li>
</ul>
<pre><code>&quot;&quot; (empty string)
0, -0, NaN (invalid number)
null, undefined
false</code></pre>
</section><section id="boolean-falsy-1" class="slide level2">
<h2>boolean falsy</h2>
<ul>
<li>Same occurs in <code>switch</code>, <code>while</code>, <code>for</code>, etc… where conditional is used</li>
<li>More on this later [Chapter 4 of the Types &amp; Grammar]</li>
<li>Author recommends:</li>
</ul>
<pre><code>If either value (aka side) in a comparison could be the true or false value, avoid == and use ===.
If either value in a comparison could be one of these specific values (0, &quot;&quot;, or [] -- empty array), avoid == and use ===.
In all other cases, you&#39;re safe to use ==. Not only is it safe, but in many cases it simplifies your code in a way that improves readability.</code></pre>
</section><section id="type-coercion-2" class="slide level2">
<h2>Type Coercion</h2>
<pre><code>var a = [1,2,3];
var b = [1,2,3];
var c = &quot;1,2,3&quot;;

a == c;     // true, coercion to string
b == c;     // true coercion to string
a == b;     // false by ref</code></pre>
</section><section id="type-coerceion" class="slide level2">
<h2>Type Coerceion</h2>
<ul>
<li>Relational operators also have coercion occur</li>
</ul>
<pre><code>var a = 41;
var b = &quot;42&quot;;
var c = &quot;43&quot;;

a &lt; b;      // true coercion to number
b &lt; c;      // true lexographic</code></pre>
</section><section id="unpredictably-predictable" class="slide level2">
<h2>Unpredictably predictable?</h2>
<ul>
<li>Not any?</li>
</ul>
<pre><code>var a = 42;
var b = &quot;foo&quot;;

a &lt; b;      // false
a &gt; b;      // false
a == b;     // false</code></pre>
<ul>
<li><code>NaN</code> is not <code>&lt;</code> <code>&gt;</code> or <code>==</code> any other value so does <code>NaN</code>==<code>NaN</code>?</li>
<li>Equality could be <code>42 == NaN</code> or <code>"42" == "foo"</code></li>
</ul>
</section></section>
<section><section id="scoping" class="title-slide slide level1"><h1>Scoping</h1></section><section id="lexical-scope" class="slide level2">
<h2>Lexical Scope</h2>
<ul>
<li>Collection of variables that can be accessed and rules for how those variables are accessed by name</li>
<li>Each function has it’s own scope</li>
<li>Each variable name must be unique within a scope, but same name can be used in different scopes</li>
</ul>
<pre><code>function one() {
    // this `a` only belongs to the `one()` function
    var a = 1;
    console.log( a );
}

function two() {
    // this `a` only belongs to the `two()` function
    var a = 2;
    console.log( a );
}

one();      // 1
two();      // 2</code></pre>
</section><section id="lexical-scope-1" class="slide level2">
<h2>Lexical Scope</h2>
<ul>
<li>Scopes can be nested</li>
<li>Inner gets access to outer but not vice versa</li>
</ul>
<pre><code>function outer() {
    var a = 1;

    function inner() {
        var b = 2;

        // we can access both `a` and `b` here
        console.log( a + b );   // 3
    }

    inner();

    // we can only access `a` here
    console.log( a );           // 1
}

outer();</code></pre>
<ul>
<li>Will get <code>ReferenceError</code> thrown if accessing variables out of scope</li>
</ul>
</section><section id="lexical-scope-2" class="slide level2">
<h2>Lexical Scope</h2>
<ul>
<li>Variables outside all functions and scopes are global variables</li>
<li>Variables and functions are hoisted</li>
</ul>
<pre><code>var a = 2;

foo();                  // works because `foo()`
                        // declaration is &quot;hoisted&quot;

function foo() {
    a = 3;

    console.log( a );   // 3

    var a;              // declaration is &quot;hoisted&quot;
                        // to the top of `foo()`
}

console.log( a );   // 2</code></pre>
</section><section id="hoisting" class="slide level2">
<h2>Hoisting</h2>
<ul>
<li>By convention avoid using hoisting for variables</li>
<li>Functions are generally acceptable but may be coding conventions to apply</li>
<li>More on this later</li>
</ul>
</section></section>
<section><section id="objects-more" class="title-slide slide level1"><h1>Objects &amp; More</h1></section><section id="objects" class="slide level2">
<h2>Objects</h2>
<ul>
<li>JSON</li>
<li>Syntax</li>
<li>Accessing</li>
<li><code>.</code> most times, <code>[]</code> for special characters in property names e.g. <code>first name</code> or using variable</li>
</ul>
<pre><code>var obj = {
    a: &quot;hello world&quot;,
    b: 42,
    c: true
};

obj.a;      // &quot;hello world&quot;
obj.b;      // 42
obj.c;      // true

obj[&quot;a&quot;];   // &quot;hello world&quot;
obj[&quot;b&quot;];   // 42
obj[&quot;c&quot;];   // true

var b = &quot;a&quot;;

obj[b];         // &quot;hello world&quot;
obj[&quot;b&quot;];       // 42</code></pre>
</section><section id="let-vs-var" class="slide level2">
<h2>let vs var</h2>
<ul>
<li>Can also use <code>let</code> to restrict scope to a block</li>
</ul>
<pre><code>function foo() {
    var a = 1;

    if (a &gt;= 1) {
        let b = 2;

        while (b &lt; 5) {
            let c = b * 2;
            b++;

            console.log( a + c );
        }
    }
}

foo();
// 5 7 9</code></pre>
</section><section id="undeclared-variables" class="slide level2">
<h2>Undeclared Variables</h2>
<ul>
<li>Undeclared variables become global variables. Don’t do this!!!</li>
</ul>
<pre><code>function foo() {
    a = 1;  // `a` not formally declared
}

foo();
a;          // 1 -- oops, auto global variable :(</code></pre>
</section><section id="strict-mode" class="slide level2">
<h2>Strict Mode</h2>
<ul>
<li>Use Strict Mode</li>
</ul>
<pre><code>&quot;use strict&quot;;

function foo() {
    // this code is strict mode
        a=1; //`var` missing, ReferenceError
    function bar() {
        // this code is strict mode
    }
}

// this code is strict mode
foo();</code></pre>
</section></section>
<section><section id="functions-1" class="title-slide slide level1"><h1>Functions</h1></section><section id="functions-2" class="slide level2">
<h2>Functions</h2>
<ul>
<li>Functions are values just like <code>42</code></li>
<li>Thus we can assign it to other variables, pass it or return it from a function</li>
</ul>
<pre><code>function foo() {
    // ..
}</code></pre>
<pre><code>var foo = function() {
    // ..
};</code></pre>
</section><section id="functions-3" class="slide level2">
<h2>Functions</h2>
<ul>
<li>Similarly first function expression is <code>anonymous function expression</code> second is <code>named function expression</code></li>
<li>Both common</li>
</ul>
<pre><code>var foo = function() {
    // ..
};

var x = function bar(){
    // ..
};</code></pre>
</section><section id="iife" class="slide level2">
<h2>IIFE</h2>
<ul>
<li>IIFE - Immediately Invoked Function Expression</li>
</ul>
<pre><code>(function(){
console.log(&#39;I am an IFFE&#39;);
})();</code></pre>
<ul>
<li>Commonly used to avoid affecting surrounding code</li>
</ul>
<pre><code>var a = 42;

(function IIFE(){
    var a = 10;
    console.log( a );   // 10
})();

console.log( a );       // 42</code></pre>
</section><section id="closure" class="slide level2">
<h2>Closure</h2>
<pre><code>function makeAdder(x) {
    // parameter `x` is an inner variable

    // inner function `add()` uses `x`, so
    // it has a &quot;closure&quot; over it
    function add(y) {
        return y + x;
    };

    return add;
}</code></pre>
<p>now</p>
<pre><code>// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusTen = makeAdder( 10 );

plusOne( 3 );       // 4  &lt;-- 1 + 3
plusOne( 41 );      // 42 &lt;-- 1 + 41

plusTen( 13 );      // 23 &lt;-- 10 + 13</code></pre>
</section><section id="module-pattern" class="slide level2">
<h2>Module Pattern</h2>
<ul>
<li>Most common usage of closure</li>
<li>Allow ‘private’ variables/functions and public API</li>
</ul>
<pre><code>function User(){
    var username, password;

    function doLogin(user,pw) {
        username = user;
        password = pw;

        // do the rest of the login work
    }

    var publicAPI = {
        login: doLogin
    };

    return publicAPI;
}

// create a `User` module instance
var fred = User();

fred.login( &quot;fred&quot;, &quot;12Battery34!&quot; );</code></pre>
<ul>
<li>More on this later</li>
</ul>
</section><section id="polyfill" class="slide level2">
<h2>Polyfill</h2>
<ul>
<li>Polyfill - adding code to replicate newer feature</li>
</ul>
<pre><code>if (!Number.isNaN) {
    Number.isNaN = function isNaN(x) {
        return x !== x;
    };
}</code></pre>
<ul>
<li>Some features can’t be polyfilled</li>
<li>In general don’t do your own polyfill</li>
</ul>
</section><section id="transpiling" class="slide level2">
<h2>Transpiling</h2>
<ul>
<li>Transpiling - Transforming + Compiling</li>
</ul>
<pre><code>function foo(a = 2) {
    console.log( a );
}

foo();      // 2
foo( 42 );  // 42</code></pre>
<pre><code>function foo() {
    var a = arguments[0] !== (void 0) ? arguments[0] : 2;
    console.log( a );
}</code></pre>
</section><section id="transpiling-1" class="slide level2">
<h2>Transpiling</h2>
<ul>
<li>New syntax typically more readable and maintainable</li>
<li>Newer browsers get performance increase by not using transpiled code</li>
<li>Allows for early feedback</li>
<li><a href="https://github.com/google/traceur-compiler">Traceur</a></li>
</ul>
</section></section>
    </div>
  </div>


  <script src="../../reveal.js/lib/js/head.min.js"></script>
  <script src="../../reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
		  { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
//          { src: '../../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: '../../reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
